/**
 * Prompt Attribution Frontend Implementation
 * Handles interactive elements for the attribution system
 */

class PromptAttributionUI {
  constructor() {
    this.apiEndpoint = '/api/prompt-attribution';
    this.activeTooltips = new Map();
    this.feedbackModal = null;
    this.init();
  }

  init() {
    // Initialize event listeners
    this.attachEventListeners();
    this.createFeedbackModal();
    this.initializeTooltips();
  }

  attachEventListeners() {
    // Attach global event delegation
    document.addEventListener('click', (e) => {
      // View Prompt button
      if (e.target.matches('[data-action="view-prompt"]')) {
        this.viewPrompt(e.target.dataset.promptId);
      }
      
      // Rate Output button
      if (e.target.matches('[data-action="rate-output"]')) {
        this.showRatingModal(e.target.dataset.executionId);
      }
      
      // Suggest Improvement button
      if (e.target.matches('[data-action="suggest-improvement"]')) {
        this.showImprovementModal(e.target.dataset.promptId);
      }
      
      // View Alternatives button
      if (e.target.matches('[data-action="view-alternatives"]')) {
        this.showAlternatives(e.target.dataset.promptId, e.target.dataset.contentType);
      }
    });

    // Hover events for inline attributions
    document.addEventListener('mouseenter', (e) => {
      if (e.target.matches('.ai-generated-content')) {
        this.showAttributionTooltip(e.target);
      }
    }, true);

    document.addEventListener('mouseleave', (e) => {
      if (e.target.matches('.ai-generated-content')) {
        this.hideAttributionTooltip(e.target);
      }
    }, true);
  }

  /**
   * Create attribution header HTML
   */
  createAttributionHeader(execution, qualityScore = null) {
    const stars = this.generateStars(qualityScore);
    const timeAgo = this.formatTimeAgo(new Date(execution.timestamp));
    
    return `
      <div class="prompt-attribution" style="border-left-color: ${this.getAnalyzerColor(execution.analyzer_type)}">
        <div class="attribution-header">
          <span class="generated-by">
            ${this.getAnalyzerIcon(execution.analyzer_type)} Generated by: 
            <a href="#" data-action="view-prompt" data-prompt-id="${execution.prompt_id}">
              ${execution.prompt_name}
            </a>
          </span>
          <span class="version-badge">v${execution.prompt_version}</span>
          <span class="quality-score">${stars}</span>
          <span class="last-updated">Updated: ${timeAgo}</span>
        </div>
        <div class="attribution-metadata">
          Analyzer: ${execution.analyzer_type} | Temperature: ${execution.temperature} | 
          Web Search: ${execution.web_search_enabled ? '‚úÖ' : '‚ùå'}
        </div>
        <div class="attribution-actions">
          <button data-action="view-prompt" data-prompt-id="${execution.prompt_id}">
            üìã View Prompt
          </button>
          <button data-action="rate-output" data-execution-id="${execution.execution_id}">
            ‚≠ê Rate Output
          </button>
          <button data-action="suggest-improvement" data-prompt-id="${execution.prompt_id}">
            üí° Suggest Improvement
          </button>
          <button data-action="view-alternatives" 
                  data-prompt-id="${execution.prompt_id}"
                  data-content-type="${execution.content_type}">
            üîÑ Alternatives
          </button>
        </div>
      </div>
    `;
  }

  /**
   * Show attribution tooltip on hover
   */
  showAttributionTooltip(element) {
    const attribution = JSON.parse(element.dataset.attribution || '{}');
    
    const tooltip = document.createElement('div');
    tooltip.className = 'attribution-tooltip';
    tooltip.innerHTML = `
      <div class="tooltip-header">
        üìä ${attribution.prompt_name || 'Unknown Prompt'}
      </div>
      <div class="tooltip-content">
        <div class="tooltip-row">
          <span class="label">Generated:</span>
          <span class="value">${new Date(attribution.timestamp).toLocaleString()}</span>
        </div>
        <div class="tooltip-row">
          <span class="label">Duration:</span>
          <span class="value">${attribution.duration || 'N/A'}</span>
        </div>
        <div class="tooltip-row">
          <span class="label">Model:</span>
          <span class="value">${attribution.model || 'claude-3-opus'}</span>
        </div>
        <div class="tooltip-row">
          <span class="label">Temperature:</span>
          <span class="value">${attribution.temperature || 'N/A'}</span>
        </div>
      </div>
    `;
    
    // Position tooltip
    const rect = element.getBoundingClientRect();
    tooltip.style.position = 'absolute';
    tooltip.style.top = `${rect.bottom + window.scrollY + 8}px`;
    tooltip.style.left = `${rect.left + window.scrollX}px`;
    
    document.body.appendChild(tooltip);
    this.activeTooltips.set(element, tooltip);
  }

  hideAttributionTooltip(element) {
    const tooltip = this.activeTooltips.get(element);
    if (tooltip) {
      tooltip.remove();
      this.activeTooltips.delete(element);
    }
  }

  /**
   * Create feedback modal
   */
  createFeedbackModal() {
    const modal = document.createElement('div');
    modal.className = 'feedback-modal hidden';
    modal.innerHTML = `
      <div class="modal-overlay"></div>
      <div class="modal-content">
        <h3>‚≠ê Rate This Output</h3>
        <div class="rating-stars">
          ${[1,2,3,4,5].map(i => `
            <span class="star" data-rating="${i}">‚òÜ</span>
          `).join('')}
        </div>
        <div class="feedback-form">
          <label>What worked well? (Optional)</label>
          <textarea id="positive-feedback" rows="3"></textarea>
          
          <label>What could be improved? (Optional)</label>
          <textarea id="improvement-feedback" rows="3"></textarea>
          
          <label>
            <input type="checkbox" id="share-with-developers">
            Share feedback with prompt developers
          </label>
        </div>
        <div class="modal-actions">
          <button class="cancel-btn">Cancel</button>
          <button class="submit-btn">Submit Rating</button>
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    this.feedbackModal = modal;
    
    // Attach modal event listeners
    this.attachModalListeners();
  }

  attachModalListeners() {
    const modal = this.feedbackModal;
    
    // Star rating
    modal.querySelectorAll('.star').forEach(star => {
      star.addEventListener('click', (e) => {
        const rating = parseInt(e.target.dataset.rating);
        this.setRating(rating);
      });
      
      star.addEventListener('mouseenter', (e) => {
        const rating = parseInt(e.target.dataset.rating);
        this.previewRating(rating);
      });
    });
    
    modal.querySelector('.rating-stars').addEventListener('mouseleave', () => {
      this.resetRatingPreview();
    });
    
    // Cancel button
    modal.querySelector('.cancel-btn').addEventListener('click', () => {
      this.closeFeedbackModal();
    });
    
    // Submit button
    modal.querySelector('.submit-btn').addEventListener('click', () => {
      this.submitFeedback();
    });
    
    // Close on overlay click
    modal.querySelector('.modal-overlay').addEventListener('click', () => {
      this.closeFeedbackModal();
    });
  }

  /**
   * Show rating modal
   */
  showRatingModal(executionId) {
    this.currentExecutionId = executionId;
    this.feedbackModal.classList.remove('hidden');
    this.currentRating = 0;
  }

  closeFeedbackModal() {
    this.feedbackModal.classList.add('hidden');
    this.resetForm();
  }

  setRating(rating) {
    this.currentRating = rating;
    const stars = this.feedbackModal.querySelectorAll('.star');
    stars.forEach((star, index) => {
      star.textContent = index < rating ? '‚òÖ' : '‚òÜ';
      star.classList.toggle('filled', index < rating);
    });
  }

  previewRating(rating) {
    const stars = this.feedbackModal.querySelectorAll('.star');
    stars.forEach((star, index) => {
      star.classList.toggle('preview', index < rating);
    });
  }

  resetRatingPreview() {
    const stars = this.feedbackModal.querySelectorAll('.star');
    stars.forEach(star => star.classList.remove('preview'));
  }

  async submitFeedback() {
    const positiveFeedback = document.getElementById('positive-feedback').value;
    const improvementFeedback = document.getElementById('improvement-feedback').value;
    const shareWithDevs = document.getElementById('share-with-developers').checked;
    
    if (this.currentRating === 0) {
      alert('Please select a rating');
      return;
    }
    
    try {
      const response = await fetch(`${this.apiEndpoint}/feedback`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          execution_id: this.currentExecutionId,
          rating: this.currentRating,
          positive_feedback: positiveFeedback,
          improvement_feedback: improvementFeedback,
          share_with_developers: shareWithDevs,
          timestamp: new Date().toISOString()
        })
      });
      
      if (response.ok) {
        this.showSuccessMessage('Thank you for your feedback!');
        this.closeFeedbackModal();
      }
    } catch (error) {
      console.error('Error submitting feedback:', error);
      alert('Failed to submit feedback. Please try again.');
    }
  }

  /**
   * Show alternative prompts
   */
  async showAlternatives(promptId, contentType) {
    try {
      const response = await fetch(
        `${this.apiEndpoint}/alternatives?prompt_id=${promptId}&content_type=${contentType}`
      );
      const alternatives = await response.json();
      
      this.displayAlternatives(alternatives);
    } catch (error) {
      console.error('Error fetching alternatives:', error);
    }
  }

  displayAlternatives(alternatives) {
    const panel = document.createElement('div');
    panel.className = 'alternatives-panel';
    panel.innerHTML = `
      <div class="panel-header">
        <h3>üîÑ Alternative Prompts</h3>
        <button class="close-btn">√ó</button>
      </div>
      <div class="alternatives-list">
        ${alternatives.map(alt => `
          <div class="alternative-prompt">
            <div class="prompt-header">
              <span class="prompt-name">${alt.name}</span>
              <span class="prompt-rating">${this.generateStars(alt.rating)}</span>
              ${alt.tag ? `<span class="prompt-tag">${alt.tag}</span>` : ''}
            </div>
            <div class="prompt-strengths">
              <strong>Better at:</strong> ${alt.strengths.join(', ')}
            </div>
            <div class="prompt-tradeoffs">
              <strong>Trade-off:</strong> ${alt.trade_offs.join(', ')}
            </div>
            <button class="try-prompt-btn" data-prompt-id="${alt.prompt_id}">
              Try This Prompt ‚Üí
            </button>
          </div>
        `).join('')}
      </div>
    `;
    
    document.body.appendChild(panel);
    
    // Close button
    panel.querySelector('.close-btn').addEventListener('click', () => {
      panel.remove();
    });
    
    // Try prompt buttons
    panel.querySelectorAll('.try-prompt-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        this.tryAlternativePrompt(e.target.dataset.promptId);
      });
    });
  }

  /**
   * View prompt details
   */
  viewPrompt(promptId) {
    // Open Notion page in new tab or in-app
    const notionUrl = `notion://page/${promptId}`;
    window.open(notionUrl, '_blank');
  }

  /**
   * Helper methods
   */
  getAnalyzerColor(analyzerType) {
    const colors = {
      'insights': '#8B5CF6',
      'summarizer': '#3B82F6',
      'classifier': '#10B981',
      'tagger': '#F59E0B',
      'technical': '#EF4444',
      'market': '#F97316',
      'legal': '#92400E'
    };
    return colors[analyzerType] || '#6B7280';
  }

  getAnalyzerIcon(analyzerType) {
    const icons = {
      'insights': 'üìä',
      'summarizer': 'üìù',
      'classifier': 'üéØ',
      'tagger': 'üè∑Ô∏è',
      'technical': 'üîß',
      'market': 'üìà',
      'legal': '‚öñÔ∏è'
    };
    return icons[analyzerType] || 'ü§ñ';
  }

  generateStars(rating) {
    if (!rating) return 'Not yet rated';
    
    const fullStars = Math.floor(rating);
    const hasHalfStar = rating % 1 >= 0.5;
    let stars = '‚≠ê'.repeat(fullStars);
    if (hasHalfStar && fullStars < 5) stars += '‚≠ê';
    
    return `${stars} (${rating.toFixed(1)}/5)`;
  }

  formatTimeAgo(date) {
    const now = new Date();
    const diff = now - date;
    
    const minutes = Math.floor(diff / 60000);
    const hours = Math.floor(diff / 3600000);
    const days = Math.floor(diff / 86400000);
    
    if (days > 0) return `${days} day${days > 1 ? 's' : ''} ago`;
    if (hours > 0) return `${hours} hour${hours > 1 ? 's' : ''} ago`;
    if (minutes > 0) return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
    return 'just now';
  }

  showSuccessMessage(message) {
    const toast = document.createElement('div');
    toast.className = 'success-toast';
    toast.textContent = message;
    document.body.appendChild(toast);
    
    setTimeout(() => {
      toast.classList.add('show');
    }, 10);
    
    setTimeout(() => {
      toast.classList.remove('show');
      setTimeout(() => toast.remove(), 300);
    }, 3000);
  }

  resetForm() {
    this.currentRating = 0;
    this.setRating(0);
    document.getElementById('positive-feedback').value = '';
    document.getElementById('improvement-feedback').value = '';
    document.getElementById('share-with-developers').checked = false;
  }
}

// Initialize on DOM ready
document.addEventListener('DOMContentLoaded', () => {
  window.promptAttributionUI = new PromptAttributionUI();
});

// Export for module usage
if (typeof module !== 'undefined' && module.exports) {
  module.exports = PromptAttributionUI;
}